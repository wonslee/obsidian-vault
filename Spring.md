---
tags: 
aliases:
  - 스프링
  - spring
---
# What

## 스프링이란?

스프링 프레임워크(Spring Framework)는 **자바 기반의 웹 애플리케이션 프레임워크**입니다. 
(엔터프라이즈 애플리케이션 개발을 위한 다양한 기능과 모듈을 제공하며, 가볍고 유연한 구조를 가지고 있습니다.)

스프링 프레임워크는 [[IoC]] & [[DI]]를  통해 애플리케이션의 객체 생성과 의존성 관리를 담당합니다. 
이를 통해 개발자는 객체 간의 의존성을 직접 관리하는 대신, **[[스프링 컨테이너]]에게 제어권을 넘김**으로써 **유연하고 확장 가능**한 애플리케이션을 구성할 수 있습니다. 애플리케이션내 객체간의 느슨한 결합도를 유지하도록 해준다. 

또한, 스프링 프레임워크는 [[AOP]]을 지원하여 애플리케이션의 부가 기능을 모듈화할 수 있습니다. 로깅, 트랜잭션 관리, 보안 등과 같은 **관심사를 분리**하여 개발자는 핵심 비즈니스 로직 개발에 집중할 수 있습니다.

[[PSA]]를 지원하여 ... 



## 스프링과 [[OOP]]
스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 [[OOP]]가 가능한 언어라는 점이다.

그래서 스프링이 가장 관심을 많이 두는 대상은 **객체**다.  
스프링은 **객체가 어떻게 설계되고, 생성되고, 관계를 맺고 사용되는지에 관심을 갖는 프레임워크**라는 사실을 꼭 기억해두자.  이 관심이 바로 IoC이다.  

스프링이란 객체지향적 설계 원칙([[SOLID]])와 여러 디자인 패턴의 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 [[프레임워크]]이다.

## 스프링 3대 요소
### [[IoC]]
스프링은 IoC를 극한까지 적용하는 프레임워크이다.  

스프링은 매우 많은 기능을 제공하고 애플리케이션의 다양한 영역과 기술에 관여한다. 
하지만 스프링의 핵심을 담당하는 건, 바로 [[빈 팩토리]] 또는 [[애플리케이션 컨텍스트]]이다.  

스프링에서는 스프링이 제어권을 갖고 직접 만들고 관계를 부여하는 오브젝트를 [[빈]](애플리케이션 [[컴포넌트]])이라고 부른다.

스프링 빈은 [[스프링 컨테이너]]가 생성, 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 객체를 가리키는 말이다.  


[[스프링 설정 정보]]라는 메타 정보를 제공해서 IoC에 쓸 수 있다.

### [[DI]]
#### 스프링의 DI 적용 방법

필드 주입, 수정자 주입, 생성자 주입이 있으며 생성자 주입이 일반적으로 가장 권장되는 방법이라고 할 수 있습니다.

##### 필드 주입 :  [[@Autowired]]
`@Autowired` 가 붙은 인스턴스 변수가 있으면, **변수 타입과 일치하는 [[애플리케이션 컨텍스트]] 내의 빈을 찾고 주입**해준다.  

일반적으로 DI를 위해선 생성자나 수정자와 같은 메서드가 필요한데, **이 경우에는 메서드가 없어도 주입이 가능**하다.   

또한 별도의 DI 설정 없이 빈을 자동으로 가져오게 된다.  
이런 방법을 타입에 의한 자동 와이어링이라고 한다.  

###### 필드 주입의 단점

**의존성이 숨는다.**
	메서드 (생성자, 수정자) 주입과 같이 퍼블릭 인터페이스에 의존성을 명시하는 것과 달리, 필드 주입은 의존하는 객체의 정보를 외부에 드러내지 않기 때문에 캡슐화가 제대로 이루어지지 않는다고 할 수 있다.   

**불변성(Immutability) 문제**
	**생성자 주입과 달리 필드 주입은 final을 선언할 수 없다.**  
	즉 객체의 불변성을 보장할 수 없다. 


필드 주입은 읽기 쉽고, 사용하기 편하다는 것 말고는 장점이 없다고 할 수 있다.

보통은 테스트에서 주로 사용된다.  

##### 수정자 주입

**선택적인 의존성을 사용할 때 유용**하다.  
**상황에 따라 의존성 주입이 가능**하다.

- 수정자 주입(setter 메서드에 @Autowired 붙이는 방법)

그러나 주입이 강제되지 않기 때문에 의존하는 객체가 주입되지 않아도 객체가 생성되고 NullPointerExceptoin이 발생할 위험성이 있다. 

굳이 `Setter Injection`을 사용하려면, 합리적인 default를 부여할 수 있고 선택적인(optional) 의존성을 사용할 때만 사용해야한다고 말한다.

##### 생성자 주입
e.g. `@Controller`

###### 생성자 주입을 사용해야 하는 이유

Spring Framework Reference에서 권장하는 방법은 생성자를 통한 주입이다.

생성자를 사용하는 방법이 좋은 이유는 **필수적으로 사용해야하는 의존성 없이는 Instance를 만들지 못하도록 강제할 수 있기 때문**이다.

- **null을 주입하지 않는 한 NullPointerException 은 발생하지 않는다.**

**의존관계 주입을 하지 않은 경우에는 Controller 객체를 생성할 수 없다.**  
즉, 의존관계에 대한 내용을 퍼블릭 인터페이스에 노출시킴으로써 컴파일 타임에 오류를 잡아낼 수 있다.

- **final 을 사용할 수 있다.**

final로 선언된 레퍼런스타입 변수는 반드시 선언과 함께 초기화가 되어야 하므로 setter 주입시에는 의존관계 주입을 받을 필드에 final 을 선언할 수 없다.

**final의 장점은 객체가 불변하도록 할 수 있는 점**으로, _누군가가 Controller 내부에서 Service 객체를 바꿔치기 할 수 없다는 점_이다.

- **순환 의존성을 알 수 있다.**

앞서 살펴 본 `Field Injection`에서는 컴파일 단계에서 순환 의존성을 검출할 방법이 없지만, `Construtor Injection`에서는 컴파일 단계에서 순환 의존성을 잡아 낼 수 있다.

- **의존성을 주입하기가 번거로워 위기감을 느낄 수 있다.**

`Construtor Injection`의 경우 생성자의 인자가 많아지면 코드가 길어지며 **개발자로 하여금 위기감을 느끼게 해준다.**

**이를 바탕으로 SRP 원칙을 생각하게 되고, Refactoring을 하게 된다.**

### [[AOP]]

### [[PSA]]


## [[Spring MVC]]



## ORM : [[JPA]]

### 선언적 트랜잭션

[[Java 예외 처리]]와 연관되어 있다.
예외 종류를 구분하는 것이 중요하다. 

스프링의 선언적 트랜잭션(@Transactional) 안에서 예외가 발생했을 때, 해당 예외가 언체크 예외(런타임 예외)라면 자동적으로 롤백이 발생한다. 하지만 체크 예외라면 롤백이 되지 않는다. 체크 예외를 롤백시키기 위해서는 @Transactional의 rollbackFor 속성으로 해당 체크 예외를 적어주어야 한다.

스프링의 트랜잭션이 언체크 예외(런타임 예외)나 에러(Error) 만을 롤백 대상으로 보는 이유는 해당 예외들이 복구 가능성이 없는 예외들이므로 별도의 try-catch나 throw를 통해 처리를 강제하지 않기 때문이다


출처: [https://mangkyu.tistory.com/170](https://mangkyu.tistory.com/170) [MangKyu's Diary:티스토리]

## [[관심사의 분리]]

어떻게 변경이 일어날 때 필요한 작업을 최소화하고 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까? 
그것은 분리와 확장을 고려한 설계가 있었기 때문이다.

문제는, 변화는 대체로 한가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다. 


# Why

스프링이 나오기전 자바 엔터프라이즈 개발은 굉장히 복잡했는데, 그 이유는 비즈니스 로직 외에도 타 프로젝트와의 연계, 분산 트랜잭션, 보안 등 고려할 사항들이 많았기 때문이다. 이와 같은 문제점들을 해결하기 위해서 spring이 등작하게 되었습니다

## 스프링이 꼭 필요한가?

토비 스프링 98p..
그렇다면 **굳이 스프링을 사용하지 않고 그냥 [DaoFactory](https://github.com/pg-server-study/spring-study/blob/main/JH/chapter1/README.md#14-%EC%A0%9C%EC%96%B4%EC%99%80-%EC%97%AD%EC%A0%84)와 같은 객체 팩토리를 만들어서 사용하면 되는게 아닐까?** 

그렇지 않다.
스프링은 DaoFactory를 통해서는 얻을 수 없는 **방대한 기능과 활용 방법을 제공**해준다. 

## [[애플리케이션 컨텍스트]]

애플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다.

### 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
팩토리 클래스를 사용한다면 클라이언트는 어떤 팩토리 클래스를 사용해야 하는지 알아야 하고, 필요할 때마다 팩토리 오브젝트를 생성해야 하는 번거로움이 있음.

애플리케이션 컨텍스트를 사용하면 일관된 방법으로 원하는 객체를 가져올 수 있다.

YML처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정 정보를 만들 수도 있다.

### 종합 [[IoC]] 서비스 제공

애플리케이션 컨텍스트의 역할은 오브젝트 생성, 관계 설정 외에도 오브젝트의 생성 방식, 시점, 전략을 다르게 가져가게 할 수 있다. 

부가적으로 자동 생성, 오브젝트 후처리, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.

### [[빈]]을 검색하는 다양한 방법 제공

getBean() 메서드, 타입 검색, 어노테이션 검색 등의 방법으로 빈을 검색할 수 있다.


# How

## 서버의 신뢰성을 보장하는 방법

## [[테스트]]

### 통합 테스트
## [[MockMvc]] 객체란?

서블릿 컨테이너의 구동 없이, 시뮬레이션된 MVC 환경에 모의 HTTP 서블릿 요청을 전송하는 기능을 제공하는 유틸리티 클래스다. 즉, MockMvc객체를 생성하여 사용하면, WAS역할을 대신하기 때문에 Tomcat을 구동하지 않고 테스트를 할 수 있다. 

#### 자주 사용하는 메서드

- perform : 요청을 처리한다. 리턴값으로 ResultActions 객체를 받으며, 이 객체는 리턴 값을 검증하고 확인할 수 있는 andExpect()를 제공한다. 
- andExpect : 응답을 검증한다.  
    상태 코드 검증  
    응답 내용 검증  
    MVC 모델 상태 검증
- andDo : 결과를 출력한다.

