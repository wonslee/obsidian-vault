---
tags:
  - cs/programming-model
---

# What
= 의존성 주입
= **객체간의 의존 관계**를 제 3자에 의해 (레퍼런스 전달을 통해) **런타임시에 연결**해주는 작업을 말한다. 스프링에서 DI를 하기 위해선 두 객체는 **빈으로 등록**되어 스프링 컨테이너에 의해 관리되는 상태여야 한다.
= DI는 객체가 필요로 하는 의존성을 외부에서 주입받는 것

= 스프링이 제공하는 IoC의 핵심이라고 할 수 있다.

## [[IoC]] vs DI
IoC는 프로그램의 제어 흐름을 객체에서 외부로 위임하는 것이고, DI는 객체가 필요로 하는 의존 객체(의존성)를 런타임시에 외부에서 주입받는 것을 의미합니다


DI의 핵심 : 어떤 객체가 다른 객체의 레퍼런스를 외부로부터 전달받아 다이나믹하게 의존 관계가 만들어진다는 것

스프링 기능의 99%가 DI의 혜택을 이용하고 있다. 
DI 없이는 스프링도 없다.  

스프링 [[IoC]] 기능의 대표적인 동작 원리는 주로 의존 관계 주입이라고 불린다.  
스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 DI라는 용어를 사용할 때 분명하게 드러난다.   

## 용어 정리 : 주입

엄밀히 말해서 객체는 다른 객체에 주입할 수 있는게 아니다. 객체의 레퍼런스가 전달될 뿐이다.  
DI는 어떤 객체가 **다른 객체의 레퍼런스를 외부로부터 전달받아 다이나믹하게 의존 관계가 만들어진다는 것이 핵심**이다.

## 시점을 기준으로 보는 의존관계 주입 
[[의존 관계#What#런타임 의존 관계]]

의존관계 주입은 이렇게 구체적인 의존 오브젝트(**구현체**)와 그것을 사용할 주체(**클라이언트 객체**) 객체를 레퍼런스 전달을 통해 런타임시에 연결해주는 작업을 말한다.

의존 관계 주입의 핵심은 **설계 시점(컴파일 시점)에는 알지 못했던 두 객체의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것**이다.


## DI 3가지 조건

### [[인터페이스]] 의존
클래스 모델이나 코드에는 런타임 시점 의존 관계가 드러나지 않는다. 
그러기 위해선 인터페이스에만 의존하고 있어야 한다.  

이미 특정 클래스 타입으로 고정되엉 있다면 DI가 일어날 수 없다.  
DI에서 말하는 주입은 다이나믹하게 구현체를 결정해서 제공받을 수 있도록 인터페이스 타입의 파라미터를 통해 이뤄져야 한다.  

### 관계 설정 책임을 맡은 제3의 존재
런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다. 

### 레퍼런스 전달
의존관계는 사용할 객체에 대한 레퍼런스를 외부에서 제공함으로써 만들어진다.  
이를 **주입**이라고 한다.


## DI를 원한다면 빈이 되어라

DI를 원하는 객체는 먼저 자기 자신이 컨테이너에 의해 관리되는 빈이 되어야 한다.  


## 누군가는 DI 컨테이너를 알아야 한다


스프링의 Ioc와 DI 컨테이너를 적용했다고 하더라도 애플리케이션 기동 시점에서 적어도 한 번은 [[DL]] 방식을 이용해 오브젝트를 가져와야 한다.  
스태틱 메서드인 main에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.   
결국 누군가는 DI 컨테이너를 알아야 한다. 


# Why

## DI의 필요성

다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다!  
다형성만으로는 OCP, DIP를 지킬 수 없다.

(의존 관계 생성 책임을 위임함으로써 ) 객체간의 느슨한 결합도를 유지하고 객체가 자신의 역할에 집중할 수 있도록 하기 위함입니다.  

## [[OCP]] 원칙 준수

[[OCP#생성 사용 분리]]를 하고 난 뒤에 자연스럽게 DI를 하게 된다.   

DI의 목적은 생성과 사용의 분리를 하기 위함이라고 할 수 있다.
즉, 세부 구현체에 대한 결합도를 낮추고 응집도는 높이게 된다. 


## 편리한 [[다형성]] 적용

![[polymorphism.png]]



  
# How

