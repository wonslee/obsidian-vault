---
tags:
  - cs/paradigm
---

# What

= 의존성 역전 원칙, Dependency Inversion Principle

자주 변하는 구체적인 클래스보다는 **변하기 어려운 인터페이스나 상위(추상) 클래스와 의존 관계를 맺으라**는 원칙

**[[추상화]]를 강조**하는 원칙.  
DIP를 준수하기 위해선 추상화를 의존해야 한다.  


의존 관계를 맺을 때 변화하기 쉬운 것에 의존하기보다는, **변화하지 않는 것에 의존**하도록 함으로써 애플리케이션을 변경에 용이하게 할 수 있습니다.  

1. **상위 모듈**은 **하위 모듈**에 의존해서는 안된다. **추상화에 의존**해야 한다. 
2. **객체는 세부 사항에** 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다. 


![](https://velog.velcdn.com/images/bigseoul/post/a25d2f8b-4e14-44d9-8588-0df9e1510d14/image.png)


### "역전"의 의미
DIP를 따르는 설계는 의존성의 방향이 전통적인 절차 지향 프로그래밍과는 반대 방향으로 나타나기 때문.  

인터페이스의 소유권에도 적용된다.  


## 구체적인 예시
#### [[JDBC Driver Manager]]

만약 JDBC Driver Manager 인터페이스가 존재하지 않고 자바 코드에서는 MySQL Driver Manager 클래스를 의존한다고 가정하겠습니다.  

확장에 유연하지 못하게 됩니다.

이 경우에, MySQL이 아닌 다른 DB 를 사용하려고 한다면 자바 코드에서 의존 관계를 갈아끼워야 하는 문제가 발생합니다.  
또한 만약 MySQL과 Oracle의 메서드 정의가 다르다면 기능이 메서드들을 모두 뒤져본 다음 호환되는 메서드들을 찾아 수정해야 합니다.   

그 대신, LSP를 지킨 인터페이스 하나를 두고 MySQL과 Oracle에서 구현하도록 한다면 클라이언트 코드에서는 변경에 자유로워지게 됩니다.

#### 삼성 페이와 애플 페이

https://huisam.tistory.com/entry/DIP

결제 객체(상위 수준 모듈)가 삼성 페이(하위 수준 모듈)에 의존하고 있다고 가정. 

여기서 애플 페이가 추가되었을 경우, 결제 객체는 변경에 영향을 받게 된다.  
간단하게는 타입으로 구분해서 조건문을 추가하는 방법이 있다.  
그러나 타입이 추가될 때마다 조건문이 변경되어야 하고 
-> 확장에 어렵고 변경에 취약한 구조. 가독성과 유지보수성을 저해시킨다.  

-> Pay 인터페이스를 만들어 의존성을 역전시키면 카드의 종류가 변경되더라도 결제 객체는 변경의 영향을 받지 않게 된다.  


#### Service에서 Repository 구현체를 의존하는 케이스

서비스에서 QueryDSL 레포지토리 구현체를 의존한다고 가정하겠습니다.  
만약 JDBC 레포지토리 구현체가 추가된다면 서비스에선 새로운 의존관계를 추가


## [[추상화]]에 의존하라

아래로 갈수록 결합도가 느슨해진다.  
- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

의존하는 대상이 추상적일수록 결합도는 더 낮아진다.  
같은 DIP여도, 추상 클래스보다 인터페이스에 의존하는 것이 더 낮은 결합도를 이룰 수 있다.  



# Why

**구체 클래스에 대한 의존성**이 높아지면 [[결합도]]가 높아지며 재사용성과 유연성이 저해되기 때문.  
반대로 추상 클래스(혹은 인터페이스)에 대한 의존 관계를 맺으면 느슨한 결합도를 통해 재사용성과 유연성이 증가되기 때문.

협력의 본질을 담고 있는 것은 상위 클래스(인터페이스)이기 때문이다.


# How

## [[추상화]]

객체들이 추상화에 의존하도록 하면 **하위 수준 클래스의 변경으로 인해 상위 수준의 클래스가 영향 받는 것을 방지**할 수 있다.  

또한 **상위 수준을 재사용할 때 하위 수준 클래스에 얽매이지 않고 다양한 컨텍스트에서 재사용이 가능**하다.  