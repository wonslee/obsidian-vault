---
tags:
---
# What

> 어떤 트랜잭션이 동작중인 과정에서 추가적인 트랜잭션을 실행할 경우 그 진행을 어떻게 처리하는가에 대한 옵션이다.

게시판에 글을 작성하는 기능을 하는 로직을 생각해 보자. 
글을 임시 저장하는 기능이 글 작성 중간 중간에 수행되고 동시에 로깅을 해야하는 상황이다. 이때 로깅 작업에서 예외가 발생했다. 
트랜잭션 전파 옵션이 Default일 경우 Rollback이 진행될 때 임시 저장되는 기능도 함께 Rollback된다. 

위의 예시 상황에서는 임시 저장 기능은 Rollback이 되선 안된다.(로깅 작업에서 문제가 발생했다고 사용자가 요구한 요청을 무시하는 건 아니라는 판단 하에) 그럼 기본 트랜잭션 **옵션**을 변경해줘야 한다.

## Spring 트랜잭션 전파 속성

SQL단에서 제공하는게 아니라 spring 단에서 제공하는 속성
	Spring은 @Transactional (선언적 트랜잭션)을 이용해 여러 트랜잭션을 묶어 하나의 큰 트랜잭션 경계를 만들 수 있다.
	따라서 기존 트랜잭션 작업 중, 추가 트랜잭션 작업을 진행해야 할 때 **해당 작업을 어떻게 진행할지 흐름을 결정**해야 한다.
	즉, 이 추가 트랜잭션의 흐름을 결정하는 옵션이 전파 속성!


[[Spring]]이 제공하는 선언적 [[트랜잭션]](트랜잭션 어노테이션, [[@Transactional]])의 장점 중 하나는 **여러 트랜잭션을 묶어서** 커다란 **하나의 트랜잭션 경계를 만들 수 있다는 점**이다. 

작업을 하다보면 기존에 트랜잭션이 진행중일 때 **추가적인 트랜잭션을 진행해야 하는 경우**가 있다. 이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이 **전파 속성(Propagation)** 이다. 

전파 속성에 따라 기존의 트랜잭션에 참여할 수도 있고, 별도의 트랜잭션으로 진행할 수도 있고, 에러를 발생시키는 등 여러 선택을 할 수 있다. 이렇게 하나의 트랜잭션이 다른 트랜잭션을 만나는 상황을 그림으로 나타내면 다음과 같다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8DLel%2FbtrIMBi5Mei%2FzG8FJfIn6FcPpSCbKsJrg1%2Fimg.png)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fs76hS%2FbtrII0RHWG6%2F7EEuYI1P8Q99SDpXEQQZUK%2Fimg.png)

이 경우에는 2개의 트랜잭션 범위가 존재하기 때문에 개별 논리 트랜잭션이 존재하지만, 실제로는 1개의 물리 트랜잭션이 사용된다. 
만약 트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. 이러한 물리 트랜잭션과 논리 트랜잭션을 정리하면 다음과 같다.

- 물리 트랜잭션: 실제 데이터베이스에 적용되는 트랜잭션으로, 커넥션을 통해 커밋/롤백하는 단위
- 논리 트랜잭션: 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하는 단위

기존의 트랜잭션이 진행중일 때 또 다른 트랜잭션이 사용되면 복잡한 상황이 발생한다. 스프링은 논리 트랜잭션이라는 개념을 도입함으로써 상황에 대한 설명을 쉽게 만들고, 다음과 같은 단순한 원칙을 세울수 있었다.

- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋됨
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백됨

출처: [https://mangkyu.tistory.com/269](https://mangkyu.tistory.com/269) [MangKyu's Diary:티스토리]

## 종류
REQUIRED와 REQUIRES_NEW만 이해하면 나머지는 바로 이해된다. 
### REQUIRED

스프링이 제공하는 기본적인(DEFAULT) 전파 속성으로, 기본적으로 2개의 **논리 트랜잭션들을 묶어 1개의 물리 트랜잭션을 사용**하는 것

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fs76hS%2FbtrII0RHWG6%2F7EEuYI1P8Q99SDpXEQQZUK%2Fimg.png)




spring boot @Transactional에서는 Propagation.REQUIRED가 default로 세팅되어 있다.

- **Default** 속성임
- 기본적으로 **부모 트랜잭션이 있으면 부모 트랜잭션에 종속**
- **부모 트랜잭션이 없으면 새로운 트랜잭션 생성**
### REQUIRES_NEW
- 부모 트랜잭션을 무시하고 **무조건 새로운 트랜잭션 생성**
- 부모 트랜잭션은 현재 트랜잭션이 종료될 때 까지 대기상태로 존재
- 자식 트랜잭션에서 예외가 발생해 Rollback이 진행돼도 **부모 트랜잭션에 Rollback이 전파되지 않는다**.
- 부모 트랜잭션에서 예외가 발생해 Rollback이 진행돼도 **자식 트랜잭션에 Rollback이 전파되지 않는다**.


### SUPPORTS
- 부모 트랜잭션이 있을 때만 해당 부모 트랜잭션에 종속
- **부모 트랜잭션이 없으면 트랜잭션이 적용되지 않는다**.

### NOT_SUPPORTED
- 부모 트랜잭션이 있으면 부모 트랜잭션을 대기시키고 트랜잭션 없이 실행
- **부모 트랜잭션이 없으면 트랜잭션 없이 실행**된다.

### MANDATORY
- 부모 트랜잭션이 있을 때만 해당 부모 트랜잭션에 종속
- **부모 트랜잭션이 없으면 예외가 발생**한다.

### NESTED
- 부모 트랜잭션이 있으면 새로운 트랜잭션 생성
- REQUIRED_NEW와는 다르다.
- **부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 
  자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다**.
- 자식 트랜잭션이 실패하면 부모 트랜잭션은 Rollback되지 않는다.
- 부모 트랜잭션이 실패하면 자식 트랜잭션은 Rollback 된다.

# Why


# How