---
aliases:
  - object oriented programming
  - 객체 지향
  - 객체 지향 프로그래밍
tags:
  - cs/paradigm
---
# What
## [[객체 지향 이전의 패러다임들]]
## OOP 특성
### [[추상화]]
### [[캡슐화]]
### [[상속]]
### [[다형성]]

## OOP 설계 원칙 : [[SOLID]] 
       
## 오브젝트 (조영호 저) 관점에서 바라보는 OOP

### [[역할]]
### [[책임]]
### [[협력]]


# Why?

## 목적은 변경과 [[유지보수성]]
[[소프트웨어 모듈의 목적]]
	훌륭한 객체 지향 설계는 데이터가 아닌 [[책임]]에 초점을 맞춰야 한다. 이유는 **변경**과 관련이 있다.

유지보수성이 목표다.
	여기서 유지보수성이란 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력을 말한다. 가장 중요한 동료는 [[캡슐화]]다.

높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 단 한가지다. 
설계를 변경하기 쉽게 만들기 때문이다. 

변경의 관점에서 [[응집도]]란 **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도**로 측정할 수 있다. 
하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이다. 반면에 다수의 모듈들 일부가 함께 변경되어야 한다면 응집도가 낮은 것이다.

변경의 관점에서 [[결합도]]란 **한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도**로 측정할 수 있다.
결합도가 높으면 높을수록 함께 변경해야 하는 모듈으 수가 늘어나기 때문에 변경하기에 어려워진다. 

반면 **[[퍼블릭 인터페이스]]** 를 수정할 때만 다른 모듈에 영향을 미치는 경우는 결합도가 낮다고 표현한다.

결합도가 높아도 상관 없는 경우도 있다. 일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다. 
자바의 Spring, ArrayList는 변경될 확률이 매우 낮기 때문에 결합도에 대해 고민할 필요가 없다. 

그러나 직접 작성한 코드는 얘기가 다르다. 

## [[관심사의 분리]]

## [[도메인 모델]]을 따르는 프로그램 구조

객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 **동일한 추상화 기법**을 사용할 수 있기 때문이다. 

도메인을 구성하는 개념들이 프로그램의 [[객체]]와 클래스로 매끄럽게 연결될 수 있다. 



## [[절차 지향]]과 객체지향의 차이

절차지향 프로그래밍은 데이터와 프로세스를 별도의 모듈에 위치시키는 방식입니다. 반복되는 코드의 함수화를 통해 재사용성을 높일 수 있으나 *유지보수성에 한계가 있습니다*.

Q. 왜 유지보수성에 한계가 있을까요?
-> 


객체지향 프로그래밍은 데이터와 프로세스를 동일 모듈에 위치시키는 방식입니다. 

객체지향 프로그래밍은 절차지향 프로그래밍에서 한 모듈에 몰려있던 **책임을 다른 객체로 분배**하고 개별 객체의 변경이 외부에 미치는 영향을 최소화함으로써 **유지보수성**을 높입니다. 

Q. 예시를 들어주실 수 있나요?
-> 
Q. 객체 변경이 외부에 미치는 영향을 최소화하는 것을 뭐라고 표현할 수 있을까요?
-> 


객체간에 메세지 전달을 함으로써 자율적인 객체의 공동체를 만들 수 있습니다.


## [[하향식 접근법]]과의 차이


## [[모듈]]

시스템을 모듈 단위로 어떻게 분해할 것인가?  
모듈은 다음 두 가지 비밀을 감춰야 한다.  

- 복잡성 : 모듈이 너무 복잡할 경우 이해하고 사용하기가 어렵다.  간단한 인터페이스를 제공해 모듈의 복잡도를 낮춰야 한다.
- 변경 가능성 : 모듈의 세부 사항을 내부로 감추고, 외부에는 쉽게 변경되지 않을 인터페이스를 제공해야 한다. 

#### 모듈의 장점

데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기 용이하다.  

네임 스페이스를 제공.

모듈은 변경의 정도에 따라 시스템을 분해하게 하며 외부로부터 데이터를 감춘다.  
따라서 모듈 내부는 높은 응집도를 유지하며, 모듈과 모듈 사이에는 [[퍼블릭 인터페이스]]를 통해서만 통신해야 하기 때문에 낮은 결합도를 유지할 수 있게 된다.

## 클래스와 [[추상 데이터 타입]]의 차이점

클래스는 상속과 다형성을 지원하지만 추상 데이터 타입은 지원하지 못한다.  

추상 데이터 타입은 타입을 추상화(캡슐화)한 것이고 클래스는 절차를 추상화(캡슐화)한 것이다.  
추상 데이터 타입이 오퍼레이션을 기준으로 타입을 묶는 것이라면, 클래스는 타입을 기준으로 오퍼레이션을 묶은 것이다.  

클래스는 타입들의 공통 로직을 부모 클래스에 정의하고 자식 클래스(타입)들이 상속받게 한다.  
클라이언트 코드는 부모 클래스의 오퍼레이션에 따라 메시지를 전송하고, 실제 클래스가 무엇인지 런타임에 결정되어 클래스별로 절차가 실행된다.  

이것이 다형성이다.  
다형성은 절차에 대한 클래스간의 차이점을 감춘다.  
OOP는 **[[절차 추상화]]** 이다.

![](https://wikibook.co.kr/images/errata/object/object-7-6.png)

이처럼 기존 클라이언트 코드에 영향을 미치지 않고 객체 타입과 행위를 추가할 수 있는 객체지향의 특성을 [[OCP]]라고 한다. 


OOP가 언제나 올바른 해결 방법은 아니다. 
만약 변경의 주된 압력이 오퍼레이션을 추가하는 것이라면 OOP의 다형성은 오히려 독이 된다.   
Employee에 오퍼레이션이 추가될 때마다 모든 서브 클래스에 해당 오퍼레이션을 오버라이딩해야 한다. 


# How


## [[디자인 패턴]]

## [[도메인 모델]]에서 출발하기

설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.   
도메인 개념을 정리하는 데 시간을 너무 많이 들이지 말고 빠르게 설계와 구현을 진행하자.  

도메인 모델은 구현의 기반이 될 때가 많다. 
그러나 실제 코드를 구현하면서 얻게 되는 통찰은 역으로 도메인의 개념을 바꾸기도 한다. 

## 미래에 일어날 변경을 상상하자

### 클래스 분리의 기준

응집도가 낮다는 것은 서로 연관성 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져있다는 것을 의미한다.  이 문제를 해결하기 위해서는 **변경의 이유에 따라 클래스를 분리해야 한다**. 

일반적으로 클래스 분리는 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다.  

이를 쉽게 찾도록 돕는 위험 징후들이 존재한다.  

첫번째 방법: **인스턴스 변수가 초기화되는 시점**을 살펴보는 것.  
[[응집도]]가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.

두번째 방법: **메서드들이 인스턴스 변수를 사용하는 방식**을 살펴보는 것.  
모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.  
클래스의 응집도를 높이기 위해선 **속성 그룹**과 해당 그룹에 접근하는 **메서드 그룹**을 기준으로 코드를 분리해야 한다. 

### 타입 분리와 [[다형성 패턴]]


### [[변경 보호 패턴]]

설계를 주도하는 것은 변경이다.  
개발자로서 변경에 대비하는 두가지 방법이 있다.  
하나는 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.  
다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.  

대부분의 경우 전자가 더 좋은 방법이지만 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승하더라도 유연성을 추가하는 두 번째 방법이 더 좋다.  


## [[UML]]


