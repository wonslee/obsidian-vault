---
tags:
  - cs/paradigm
aliases:
  - 일반화
---

# What
: **기존의 클래스를 재활용하여 새로운 클래스를 작성**

이미 정의된 **상위 클래스**(super class)의 모든 속성과 연산을 하위클래스가 **물려 받는 것**을 의미한다.

- 일반화를 이용하면 상위 클래스로 부터 상속받은 하위 클래스는 모든 속성(필드)과 연산(메소드)을 다시 정의하지 않고 자신의 것으로 사용 가능.
- 상속받은 속성과 연산 외에 새로운 속성과 연산을 추가하여 사용 가능하다.
- 클래스를 재사용 -> **소프트웨어 재사용성을 증대**시키는 중요한 개념이다.


# Why

## [[DRY]] 원칙

**중복 코드는 변경을 방해한다.**  

**변경 포인트를 최소화**해야 한다.  

중복 코드를 추가하는 과정에서 코드의 일관성이 무너질 위험이 있다.  
이는 변경에 취약해지고 버그 발생 가능성을 높인다.  

상속은 코드 중복을 해결하는 강력한 도구다.  
 

## [[다형성]]의 수단

**[[다형성]]** 

## [[결합도]] 문제
상속은 간단해보이지만 사실 많은 한계점이 있다. 

상속 관계는 슈퍼-서브 클래스간의 **높은 결합도**를 낳는다.

상속을 이용해 코드를 재사용하기 위해선 부모 클래스의 개발자가 세운 가정이나 배경을 추론하고 정확히 이해해야 한다.  

상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다. 
상속은 **재사용성을 위해서 캡슐화를 희생**한다.

만약 어떤 객체가 상속을 여러번 사용해야 한다면?
java 에서는 다중 상속을 허용하지 않는다.


슈퍼 클래스 내부의 변경이 있을 때 모든 서브 클래스를 함께 수정해야 할 수도 있다.  



### 취약한 기반 클래스 문제

= 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상

취약한 기반 클래스는 캡슐화를 약화시키고 결합도를 높인다.  

자식 클래스가 **부모 클래스의 구현 세부사항에 의존**하도록 만들기 때문이다.

### 불필요한 인터페이스 상속 문제
![](https://blog.kakaocdn.net/dn/kWkYg/btq6tTPd6M5/rOYnYG6c1kXKFOKGaztlh1/img.png)

add, remove 메서드는 Stack의 LIFO 규칙을 깨버린다.  
개발자의 입장에서는 Stack 객체 인스턴스를 만들어서 마지막에 add() 메서드로 원소를 삽입한다면 스택의 규칙을 깨게 된다.  


### 메서드 오버라이딩의 부작용 문제            


## [[추상화#상속의 문제 해결 - 추상화에 의존하자]]


### 그래도 결합도 문제는 피할 수 없다.

추상화를 통해 메서드에 대한 변경 영향을 최소화할 수 있다. (SRP)
그러나 인스턴스 변수에 대해서는 결합도 문제를 피할 방법이 없다.  

객체의 행동만 변경된다면 상속 계층에 속한 각 클래스들을 독립적으로 변경시킬 수 있다.  
그러나 인스턴스 변수가 추가된다면? 혹은 삭제된다면?

결국 자식 클래스는 생성자에서 부모 클래스에 정의된 인스턴스 변수를 초기화(`super(...)`해야 하기 때문에 인스턴스 변수의 변경은 최소한 자식 클래스의 초기화 로직에 변경 영향을 미친다.  

상속 계층 전반에 걸친 변경을 유발하는 것.  

그러나 이것은 상속을 하지 않음으로써 코드를 중복시키는 것보다는 현명한 선택이다.  
객체 생성 로직의 변경을 막기보다는 핵심 로직의 중복을 막아라.  

상속은 강력한 도구다.  
코드 재사용 측면에서 정말 강력한 도구이지만, 잘못 사용할 경우에 돌아오는 피해 역시 크다.  

정말로 필요한 경우에만 상속을 사용하자.  

코드 재사용을 더 우아하게 해결하려면 [[합성]]을 사용할 수 있다.  


- [C] aa
- [1] lala 
- [2] hello!
- [ ] 
# How
## [[추상 클래스]]

## [[인터페이스]]


## 추상 클래스와 인터페이스의 차이는 무엇인가요?

